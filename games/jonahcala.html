<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jonahcala - Game Arcade</title>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
    <div class="container">
        <div class="game-header">
            <h1>Jonahcala</h1>
            <a href="../index.html" class="back-btn">&#8592; Back to Games</a>
        </div>

        <div id="setup" class="game-container">
            <h2 style="text-align: center; margin-bottom: 20px;">Select Game Mode</h2>

            <div class="mode-selection">
                <button class="mode-btn active" data-mode="ai">vs Computer</button>
                <button class="mode-btn" data-mode="pvp">2 Players</button>
            </div>

            <div id="difficulty-section" class="difficulty-selection">
                <button class="difficulty-btn" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn active" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
            </div>

            <div class="btn-group" style="margin-top: 20px;">
                <button class="btn btn-success" onclick="startGame()">Start Game</button>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: var(--dark-bg); border-radius: 10px;">
                <h4 style="margin-bottom: 10px;">How to Play:</h4>
                <ul style="color: var(--text-secondary); font-size: 0.9rem; padding-left: 20px;">
                    <li>Click a pit on your side to pick up all stones</li>
                    <li>Stones are distributed counter-clockwise, one per pit</li>
                    <li>If your last stone lands in a pit with stones, pick them all up and keep sowing</li>
                    <li>Your turn ends when your last stone lands in your store or an empty pit</li>
                    <li>Game ends when one side is empty - remaining stones go to the opponent</li>
                </ul>
            </div>
        </div>

        <div id="game" class="game-container" style="display: none;">
            <div class="game-status" id="status">Player 1's turn</div>

            <div class="mancala-board" id="board">
                <div class="mancala-store" id="store2">0</div>
                <div class="mancala-pits">
                    <div class="mancala-row" id="row2"></div>
                    <div class="mancala-row" id="row1"></div>
                </div>
                <div class="mancala-store" id="store1">0</div>
            </div>

            <div class="score-display">
                <div class="score-item">
                    <span class="label" id="player1Label">Player 1</span>
                    <span class="value" id="score1">0</span>
                </div>
                <div class="score-item">
                    <span class="label" id="player2Label">Player 2</span>
                    <span class="value" id="score2">0</span>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="resetGame()">New Game</button>
                <button class="btn btn-secondary" onclick="backToSetup()">Change Mode</button>
            </div>
        </div>

        <div class="game-container">
            <h3 style="margin-bottom: 15px;">Statistics</h3>
            <div id="stats"></div>
        </div>
    </div>

    <script src="../js/utils.js"></script>
    <script>
        // Game state
        // Board layout: pits[0-5] = Player 1's pits, pits[6] = Player 1's store
        //               pits[7-12] = Player 2's pits, pits[13] = Player 2's store
        let pits = [];
        let currentPlayer = 1;
        let gameActive = false;
        let gameMode = 'ai';
        let difficulty = 'medium';
        let player1Name, player2Name;
        let isAnimating = false;

        function init() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameMode = btn.dataset.mode;
                    document.getElementById('difficulty-section').style.display =
                        gameMode === 'ai' ? 'flex' : 'none';
                });
            });

            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    difficulty = btn.dataset.difficulty;
                });
            });

            GameUtils.renderStats('jonahcala', 'stats');
        }

        function startGame() {
            player1Name = GameUtils.playerName.get(1);
            player2Name = gameMode === 'ai' ? 'Computer' : GameUtils.playerName.get(2);

            document.getElementById('player1Label').textContent = player1Name;
            document.getElementById('player2Label').textContent = player2Name;

            document.getElementById('setup').style.display = 'none';
            document.getElementById('game').style.display = 'block';

            resetGame();
        }

        function backToSetup() {
            document.getElementById('setup').style.display = 'block';
            document.getElementById('game').style.display = 'none';
        }

        function resetGame() {
            pits = [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0];
            currentPlayer = 1;
            gameActive = true;
            isAnimating = false;
            renderBoard();
            updateStatus();
        }

        function renderBoard() {
            const row1 = document.getElementById('row1');
            const row2 = document.getElementById('row2');

            row1.innerHTML = '';
            row2.innerHTML = '';

            // Player 1's pits (bottom row, left to right: 0-5)
            for (let i = 0; i < 6; i++) {
                const pit = createPit(i, pits[i], 1);
                row1.appendChild(pit);
            }

            // Player 2's pits (top row, right to left: 12-7)
            for (let i = 12; i >= 7; i--) {
                const pit = createPit(i, pits[i], 2);
                row2.appendChild(pit);
            }

            // Stores
            document.getElementById('store1').innerHTML = `<div class="mancala-stones">${renderStones(pits[6])}</div>`;
            document.getElementById('store2').innerHTML = `<div class="mancala-stones">${renderStones(pits[13])}</div>`;

            // Update scores
            document.getElementById('score1').textContent = pits[6];
            document.getElementById('score2').textContent = pits[13];
        }

        function renderStones(count) {
            if (count === 0) return '';
            if (count > 6) return `<span class="stone-count">${count}</span>`;
            let html = '';
            for (let i = 0; i < count; i++) {
                html += '<span class="mancala-stone"></span>';
            }
            return html;
        }

        function createPit(index, stones, player) {
            const pit = document.createElement('button');
            pit.className = 'mancala-pit';
            pit.innerHTML = renderStones(stones);
            pit.dataset.index = index;

            const isCurrentPlayerPit = (player === 1 && index <= 5) || (player === 2 && index >= 7 && index <= 12);
            const canClick = gameActive && !isAnimating &&
                ((currentPlayer === 1 && index <= 5) || (currentPlayer === 2 && index >= 7 && index <= 12)) &&
                stones > 0;

            if (!canClick) {
                pit.disabled = true;
            } else {
                pit.addEventListener('click', () => makeMove(index));
            }

            if (currentPlayer === player && isCurrentPlayerPit && stones > 0) {
                pit.classList.add('highlight');
            }

            return pit;
        }

        async function makeMove(pitIndex) {
            if (!gameActive || isAnimating) return;
            if (pits[pitIndex] === 0) return;

            // Validate it's the current player's pit
            if (currentPlayer === 1 && pitIndex > 5) return;
            if (currentPlayer === 2 && (pitIndex < 7 || pitIndex > 12)) return;

            isAnimating = true;

            const ownStore = currentPlayer === 1 ? 6 : 13;
            const opponentStore = currentPlayer === 1 ? 13 : 6;

            let currentIndex = pitIndex;

            // Relay sowing: keep picking up and sowing until landing in store or empty pit
            while (true) {
                let stones = pits[currentIndex];
                pits[currentIndex] = 0;

                // Distribute stones
                while (stones > 0) {
                    currentIndex = (currentIndex + 1) % 14;

                    // Skip opponent's store
                    if (currentIndex === opponentStore) continue;

                    pits[currentIndex]++;
                    stones--;

                    renderBoard();
                    await GameUtils.delay(150);
                }

                // Check where the last stone landed
                // If it landed in own store, turn ends (landed in store)
                if (currentIndex === ownStore) {
                    break;
                }

                // If it landed in an empty pit (the stone we just placed is the only one), turn ends
                if (pits[currentIndex] === 1) {
                    break;
                }

                // Otherwise, pick up all stones from that pit and continue sowing
                renderBoard();
                await GameUtils.delay(300);
            }

            // Check if game is over
            if (isGameOver()) {
                endGame();
                isAnimating = false;
                return;
            }

            // Turn always passes to the other player in Jonahcala
            currentPlayer = currentPlayer === 1 ? 2 : 1;

            isAnimating = false;
            renderBoard();
            updateStatus();

            // AI move
            if (gameMode === 'ai' && currentPlayer === 2 && gameActive) {
                await GameUtils.delay(500);
                aiMove();
            }
        }

        function isGameOver() {
            const player1Empty = pits.slice(0, 6).every(p => p === 0);
            const player2Empty = pits.slice(7, 13).every(p => p === 0);
            return player1Empty || player2Empty;
        }

        function endGame() {
            gameActive = false;

            // Collect remaining stones
            const player1Remaining = pits.slice(0, 6).reduce((a, b) => a + b, 0);
            const player2Remaining = pits.slice(7, 13).reduce((a, b) => a + b, 0);

            // The player whose side is NOT empty gets the opponent's remaining stones
            if (pits.slice(0, 6).every(p => p === 0)) {
                pits[13] += player2Remaining;
            } else {
                pits[6] += player1Remaining;
            }

            // Clear the pits
            for (let i = 0; i < 6; i++) pits[i] = 0;
            for (let i = 7; i < 13; i++) pits[i] = 0;

            renderBoard();

            const statusEl = document.getElementById('status');
            if (pits[6] > pits[13]) {
                statusEl.textContent = `${player1Name} wins! (${pits[6]} - ${pits[13]})`;
                statusEl.classList.add('winner');
                if (gameMode === 'ai') {
                    GameUtils.stats.update('jonahcala', 'win');
                    GameUtils.highScores.add('jonahcala', player1Name, pits[6], { opponent: pits[13] });
                } else {
                    GameUtils.stats.update('jonahcala', 'win');
                }
            } else if (pits[13] > pits[6]) {
                statusEl.textContent = `${player2Name} wins! (${pits[13]} - ${pits[6]})`;
                statusEl.classList.add('winner');
                if (gameMode === 'ai') {
                    GameUtils.stats.update('jonahcala', 'loss');
                } else {
                    GameUtils.stats.update('jonahcala', 'win');
                }
            } else {
                statusEl.textContent = `It's a tie! (${pits[6]} - ${pits[13]})`;
                GameUtils.stats.update('jonahcala', 'draw');
            }

            GameUtils.renderStats('jonahcala', 'stats');
        }

        function updateStatus() {
            const statusEl = document.getElementById('status');
            statusEl.classList.remove('winner');
            const playerName = currentPlayer === 1 ? player1Name : player2Name;
            statusEl.textContent = `${playerName}'s turn`;
        }

        // Simulate a move without animation to evaluate outcome
        function simulateMove(pitsCopy, pitIndex, player) {
            const ownStore = player === 1 ? 6 : 13;
            const opponentStore = player === 1 ? 13 : 6;
            let currentIndex = pitIndex;

            while (true) {
                let stones = pitsCopy[currentIndex];
                pitsCopy[currentIndex] = 0;

                while (stones > 0) {
                    currentIndex = (currentIndex + 1) % 14;
                    if (currentIndex === opponentStore) continue;
                    pitsCopy[currentIndex]++;
                    stones--;
                }

                if (currentIndex === ownStore) break;
                if (pitsCopy[currentIndex] === 1) break;
            }

            return pitsCopy;
        }

        async function aiMove() {
            if (!gameActive || currentPlayer !== 2) return;

            let move;
            switch (difficulty) {
                case 'easy':
                    move = getRandomMove();
                    break;
                case 'medium':
                    move = Math.random() > 0.4 ? getBestMove() : getRandomMove();
                    break;
                case 'hard':
                    move = getBestMove();
                    break;
            }

            if (move !== null) {
                await makeMove(move);
            }
        }

        function getRandomMove() {
            const available = [];
            for (let i = 7; i <= 12; i++) {
                if (pits[i] > 0) available.push(i);
            }
            return available[Math.floor(Math.random() * available.length)];
        }

        function getBestMove() {
            const available = [];
            for (let i = 7; i <= 12; i++) {
                if (pits[i] > 0) available.push(i);
            }

            let bestMove = available[0];
            let bestScore = -Infinity;

            for (const pit of available) {
                const pitsCopy = [...pits];
                simulateMove(pitsCopy, pit, 2);

                // Score = AI store - Player store + positional advantage
                let score = pitsCopy[13] - pitsCopy[6];

                // Bonus for ending in store (lands in store)
                const ownStore = 13;
                // Simulate to check where last stone lands
                const testPits = [...pits];
                let currentIndex = pit;
                let ended = false;
                while (true) {
                    let stones = testPits[currentIndex];
                    testPits[currentIndex] = 0;
                    while (stones > 0) {
                        currentIndex = (currentIndex + 1) % 14;
                        if (currentIndex === 6) continue;
                        testPits[currentIndex]++;
                        stones--;
                    }
                    if (currentIndex === 13) { ended = true; break; }
                    if (testPits[currentIndex] === 1) break;
                }

                // Prefer moves that end in store (though turn passes regardless)
                if (ended) score += 2;

                // Prefer keeping stones on own side
                const ownStones = pitsCopy.slice(7, 13).reduce((a, b) => a + b, 0);
                score += ownStones * 0.1;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = pit;
                }
            }

            return bestMove;
        }

        init();
    </script>
</body>
</html>
